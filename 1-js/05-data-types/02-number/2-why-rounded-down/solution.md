在内部，`6.35` 的小数部分是一个无限的二进制。在这种情况下，它的存储会造成精度损失。

让我们来看看：

```js run
alert( 6.35.toFixed(20) ); // 6.34999999999999964473
```

精度损失可能会导致数字的增加和减小。在这种特殊的情况下，数字变小了一点，这就是它向下舍入的原因。

那么 `1.35` 会怎样呢？

```js run
alert( 1.35.toFixed(20) ); // 1.35000000000000008882
```

在这里，精度损失使得这个数字稍微大了一些，因此其向上舍入。

**如果我们希望以正确的方式进行舍入，我们应该如何解决 `6.35` 的舍入问题呢？**

在进行舍入前，我们应该使其更接近整数：

```js run
alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
```

请注意，`63.5` 完全没有精度损失。这是因为小数部分 `0.5` 实际上是 `1/2`。以 2 的整数次幂为分母的小数在二进制数字系统中可以被精确地表示，现在我们可以对它进行舍入：


```js run
alert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
```

