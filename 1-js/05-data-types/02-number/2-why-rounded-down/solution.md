在 `6.35` 内部，小数部分是一个无限的二进制。在这种情况下，它存储的时候有一个精度的缺失。

让我们来看看:

```js run
alert( 6.35.toFixed(20) ); // 6.34999999999999964473
```

精度缺失可能会导致数字的增加和减小。在这种特殊情况下，数字可能会变小了一点，这就是为什么它减小了。

那么 `1.35` 是怎样样的呢?

```js run
alert( 1.35.toFixed(20) ); // 1.35000000000000008882
```

在这里，精度缺失使得这个数字更大一些，所以这个数字变大了一些。

**如果我们希望以正确的方式四舍五入，我们如何使用 `6.35` 为例来解决这个问题?**

在四舍五入之前，我们应该把它接近整数:

```js run
alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
```

请注意 `63.5` 完全没有精度缺失。这是因为小数部分 `0.5` 实际上是 `1 / 2` 。除以2的幂的分数在二进制系统中被精确地表示，现在我们可以围绕它来解决问题:


```js run
alert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4
```

