回顾之前的问题，我们用 `pattern:-?\d+(\.\d+)?` 来匹配数字。

`pattern:[-+*/]` 匹配运算符。我们把 `pattern:-` 放在最前面，因为如果放在中间的话，则表示字符范围，这并不是我们想要的。

注意，在 JavaScript 中，`pattern:/.../` 中的 `/` 需要被转义。

我们需要匹配一个数字、一个运算符还有另一个数字。除此以外，还有它们之间可能存在的空格。

完整的正则表达式为：`pattern:-?\d+(\.\d+)?\s*[-+*/]\s*-?\d+(\.\d+)?`。

为了将得到的结果转化为数组，我们须将所需的数据：数字及运算符，包裹在括号中，对应的表达式为：`pattern:(-?\d+(\.\d+)?)\s*([-+*/])\s*(-?\d+(\.\d+)?)`。

实际操作：

```js run
let reg = /(-?\d+(\.\d+)?)\s*([-+*\/])\s*(-?\d+(\.\d+)?)/;

alert( "1.2 + 12".match(reg) );
```

结果包括：

- `result[0] == "1.2 + 12"` （完整匹配）
- `result[1] == "1"` （第一个捕获组）
- `result[2] == ".2"` （第二个捕获组 —— 小数部分）
- `result[3] == "+"` （...）
- `result[4] == "12"` （...）
- `result[5] == undefined` （最后一个小数部分不存在，因此为 undefined）

我们只需要数字和运算符，不需要小数部分。

因此，我们可以加上 `pattern:?:` 来去除多余的捕获组，例如：`pattern:(?:\.\d+)?`。

最终答案：

```js run
function parse(expr) {
  let reg = /(-?\d+(?:\.\d+)?)\s*([-+*\/])\s*(-?\d+(?:\.\d+)?)/;

  let result = expr.match(reg);

  if (!result) return;
  result.shift();

  return result;
}

alert( parse("-1.23 * 3.45") );  // -1.23, *, 3.45
```
