一个数字的正则表达式为： `pattern:-?\d+(\.\d+)?`。我们在之前的任务中创建过。

运算操作符的模式为 `pattern:[-+*/]`。连字符 `pattern:-` 在方括号内的第一位，因为放在中间可能表示字符范围，而我们只想表示一个字符 `-`。

在 JavaScript 的正则表达式内部应该避免出现斜杠 `/`，具体我们稍后处理。

我们需要一个数字，一个操作符然后另一个数字。其间有可选的空格。

整体的正则表达式为： `pattern:-?\d+(\.\d+)?\s*[-+*/]\s*-?\d+(\.\d+)?`。

它包含 3 部分，每部分之前有 `pattern:\s*`：
1. `pattern:-?\d+(\.\d+)?` - 第一个数字，
2. `pattern:[-+*/]` - 操作符，
3. `pattern:-?\d+(\.\d+)?` - 第二个数字。

为了使这里的每一部分成为结果数组中的独立元素，让我们将它们放在括号中： `pattern:(-?\d+(\.\d+)?)\s*([-+*/])\s*(-?\d+(\.\d+)?)`。

实现：

```js run
let regexp = /(-?\d+(\.\d+)?)\s*([-+*\/])\s*(-?\d+(\.\d+)?)/;

alert( "1.2 + 12".match(regexp) );
```

结果包含：

- `result[0] == "1.2 + 12"` (完全匹配)
- `result[1] == "1.2"` (第一组 `(-?\d+(\.\d+)?)` -- 第一个数字，包括小数部分)
- `result[2] == ".2"` (第二组 `(\.\d+)?` -- 第一个数字的小数部分)
- `result[3] == "+"` (第三组 `([-+*\/])` -- 操作符)
- `result[4] == "12"` (第四组 `(-?\d+(\.\d+)?)` -- 第二个数字)
- `result[5] == undefined` (fifth group `(\.\d+)?` -- 第二个数字的小数部分是缺失的，所以这里是 undefined)

我们只想要数字和操作符，而不是完全的匹配或小数部分，所以让我们把结果做一些处理。

完全匹配（数组的第一项）可以通过数组的出队操作 `result.shift()` 来删去。

包含小数部分的组（第 2 和第 4 个）`pattern:(.\d+)` 可以通过在开头 `pattern:(?:\.\d+)?` 添加 `pattern:?:` 来排除。

最终的解答：

```js run
function parse(expr) {
  let regexp = /(-?\d+(?:\.\d+)?)\s*([-+*\/])\s*(-?\d+(?:\.\d+)?)/;

  let result = expr.match(regexp);

  if (!result) return [];
  result.shift();

  return result;
}

alert( parse("-1.23 * 3.45") );  // -1.23, *, 3.45
```
